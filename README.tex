 %! program = pdflatex
 
 \documentclass[12pt]{article}
 \usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
 \usepackage{listings}
 \geometry{a4paper} % or letter or a5paper or ... etc
 % \geometry{landscape} % rotated page geometry
 \lstset{numbers=left, numberstyle=\tiny, numbersep=5pt} \lstset{language=Java}
 % See the ``Article customize'' template for come common customizations
 
 \title{}
 \author{}
 \date{} % delete this line to display the current date
 
 %%% BEGIN DOCUMENT
 \begin{document}
 
  \section{Description}
 Perfidix is a generic benchmarking tool which works with similar annotations as JUnit 4.x. Methods which are void and parameter-free can be annotated. The annotated methods are then executed multiple times and the time of their execution is measured. Several statistical computations will then be applied to this results. A table with all results will then given back to the user. \\
 Perfidix gives the possibility, similar to JUnit, of settingUp and cleaning methods which can be used for settings which should not be measured in the bench itself. Below, all possible annotations are listed.
 \section{Annotations}
All methods annotated with the following metadata should be parameter and returnvalue free. Each annotation mustn't occur more than one time in a class, except the \emph{Bench} annotation:
\subsection{"@BenchClass"}
\begin{itemize}
\item Has to be placed before the class declaration
\item Each void-method, which has none of the below annotations is benched.
\end{itemize}
\subsubsection{"@BenchClass(runs=)"}
\begin{itemize}
\item Sets the number of runs for all benchs
\item Can be overridden by the \emph{Bench} annotation with own run-parameter
\end{itemize}
\subsection{"@BeforeBenchClass"}
\begin{itemize}
\item Executed before the first bench-method
\item Executed once per class
\end{itemize}
\subsection{"@BeforeFirstBenchRun"}
\begin{itemize}
\item Executed before every bench-method and after the \emph{BeforeBenchClass} - annotated method
\item Executed for all bench-methods but just once for all runs
\end{itemize}
\subsection{"@BeforeEachBenchRun"}
\begin{itemize}
\item Executed before every bench-method and after the \emph{BeforeFirstBenchRun} - annotated method
\item Executed for all bench-methods before every run
\end{itemize}
\subsection{"@Bench"}
\begin{itemize}
\item Annotates method to bench
\end{itemize}
\subsubsection{"@Bench(beforeFirstBenchRun=)"} 
\begin{itemize}
\item Specific setUp-method for this bench for settings before the bench
\item is executed once for this bench
\end{itemize}
\subsubsection{"@Bench(beforeEachBenchRun=)"} 
\begin{itemize}
\item Specific setUp-method for this bench for settings before the bench
\item is executed for every run for this bench
\end{itemize}
\subsubsection{"@Bench(afterEachBenchRun=)"}
\begin{itemize}
\item Specific tearDown-method for this bench after the bench
\item is executed after every run for this bench
\end{itemize}
\subsubsection{"@Bench(afterLastBenchRun=)"}
\begin{itemize}
\item Specific tearDown-method for this bench after the bench
\item is executed after the last run of this bench
\end{itemize}
\subsubsection{"@Bench(runs=)"}
\begin{itemize}
\item Sets the number of runs for this method. 
\item Overrides the default value and a possible setting from a  \emph{BenchClass} annotation of the corresponding class.
\end{itemize}
\subsection{"@AfterEachBenchRun"}
\begin{itemize}
\item Executed after every bench-method
\item Executed for all bench-methods after every run
\end{itemize}
\subsection{"@AfterLastBenchMethod"}
\begin{itemize}
\item Executed after every bench-method and after the \emph{AfterEachBenchRun} - annotated method
\item Executed  for all bench-methods after the last run
\end{itemize}
\subsection{"@AfterBenchClass"}
\begin{itemize}
\item Executed after the last bench-method and after the \emph{AfterLastBenchRun} - annotated method
\item Executed once per class
\end{itemize}
\subsection{"@SkipBench"}
\begin{itemize}
\item Will be ignored by perfidix except the method is invoked as a specfic setUp- / tearDown method
\item Useful in combination with the \emph{BenchClass} annotation and a specific setUp- / tearDown method of one bench.
\end{itemize}
\newpage
\section{Example Use Cases}
Perfidix 2.1 offers a very flexible usage based on annotation. The examples contains all the same usecase but are different implemented. A compressed file access is compared to a normal file access.
\subsection{Example 1}
The code in Listing 1,2 and 3 are doing exact the same. The \emph{setUp()} and \emph{tearDown()} methods are invoked before each run of each method. But with Perfidix 2.0 we can do much more.
\begin{lstlisting}[caption=Perfidix 2.0]
public class SomeAnnoBenchmark {
	CompressedHandler c;
	SimpleFileHandler s;

	//setUp, invoked before each run
	@BeforeEachBenchRun
	public void setUp() {
		c = new CompressedHandler();
		s = new SimpleFileHandler();
	}

	//tearDown, invoked after each run
	@AfterEachBenchRun
	public void tearDown() {
		c = null;
		s = null;
	}

	//bench Method 1
	@Bench
	public void benchCWrite() {
		c.write("hello world");
	}

	//bench Method 2
	@Bench
	public void benchSWrite() {
		s.write("hello world");
	}

	//bench Method 3
	@Bench
	public void benchCRead() {
		c.read();
	}

	//bench Method 1
	@Bench
	public void benchSRead() {
		s.read();
	}
}
\end{lstlisting}

\subsection{Example 2}
In Listing 4 you see the usage of specific setUp and tearDown methods. These methods have the same behaviour than methods with the \emph{BeforeBenchRun} annotation.
\begin{lstlisting}[caption=Perfidix 2.0]
public class SomeSpecificSetUpTearDownBenchmark {
  CompressedHandler c;
  SimpleFileHandler s;

  //setUp for benchCRead/benchCWrite. Invoked via @Bench-params
  public void setUpCompressed() {
	c = new CompressedHandler();
  }

  //tearDown for benchCRead/benchCWrite. Invoked via @Bench-params
  public void tearDownCompressed() {
	c = null;
  }

  //setUp for benchSRead/benchSWrite. Invoked via @Bench-params
  public void setUpSimple() {
	s = new SimpleFileHandler();
  }

  //tearDown for benchSRead/benchSWrite. Invoked via @Bench-params
  public void tearDownSimple() {
	s = null;
  }

  //bench Method 1	
  @Bench(beforeEachBenchRun="setUpCompressed"
  	,afterEachBenchRun="tearDownCompressed")
  public void benchCWrite() {
	c.write("hello world");
  }
  
  //bench Method 2
  @Bench(beforeEachBenchRun ="setUpSimple"
  	, afterEachBenchRun ="tearDownSimple")
   public void benchSWrite() {
	s.write("hello world");
  }
  
  //bench Method 3	
  @Bench(beforeEachBenchRun ="setUpCompressed"
  	, afterEachBenchRun ="tearDownCompressed")
  public void benchCRead() {
	c.read();
  }

  //bench Method 4	
  @Bench(beforeEachBenchRun ="setUpSimple"
  	, afterEachBenchRun ="tearDownSimple")
  public void benchSRead() {
	s.read();
  }

}
\end{lstlisting}

\subsection{Example 3}
In Listing 5 the same Bench is a little bit modified: \\
First of all, the class-annotation \emph{BenchClass} with the param \emph{runs} is used. That means that every method which is parameter-free and is not annotated with a setUp / tearDown annotation, is benched 10 times, except the \emph{benchSWrite} method, which has an extra \emph{Bench} annotation with a run parameter. This method is benched 60 times.\\
Additional to that, every possible setUp and tearDown method is used in this example. A description is given in the code and in Section 3.
\begin{lstlisting}[caption=Perfidix 2.0]
@BenchClass(runs=10)
public class ClassAnnoBenchmark {

	CompressedHandler c;
	SimpleFileHandler s;

	String toTest;
	long testLength;

	//classwide setUp, invoked just one time, just setting the length of the string to compress.
	@BeforeBenchClass
	public void beforeClass() {
		Math.abs(testLength = new Random().nextInt(100));
	}

	//methodWide setUp, invoked just one time per method, building a string of a given length
	@BeforeFirstBenchRun
	public void beforeMethod() {
		for(int i = 0; i<testLength; i++) {
			toTest = toTest + (char)(new Random().nextInt(Character.MAX_VALUE + 1));
		}
	}

	//normal setUp, invoked one time per method per run, instantiating the handlers
	@BeforeEachBenchRun
	public void beforeRun() {
		c = new CompressedHandler();
		s = new SimpleFileHandler();
	}

	//normal tearDown, invoked one time per method per run, removing the handlers
	@AfterEachBenchRun
	public void afterRun() {
		c = null;
		s = null;
	}
	
	//methodWide tearDown, invoked just one time per Method, reseting the testString
	@AfterLastBenchRun
	public void afterMethod(){
		toTest = null;
	}
	
	//classwide tearDown, invoked just one time, reseting the length of the string
	@AfterBenchClass
	public void afterClass() {
		testLength = -1;
	}

	//bench 1, invoked because of class-annotation
	public void benchCWrite() {
		c.write("hello world");
	}

	//bench 2, invoked because of method-annotation
	@Bench(runs=60)
	public void benchSWrite() {
		s.write("hello world");
	}

	//bench 3, invoked because of class-annotation
	public void benchCRead() {
		c.read();
	}

	//bench 4, invoked because of class-annotation
	public void benchSRead() {
		s.read();
	}


}
\end{lstlisting}


 \end{document}